%{
#include <iostream>
#include <string>

#include "../config.h"
#include "../forward.h"
#include "../AST.h"
#include "../primitives.h"
#include "../MathHelper.h"
#include "../Values.h"
#include "../Expressions.h"

#include "parser.tab.hpp"

// Declare yylex for Bison
extern int yylex();

// Error reporting function
void yyerror(const char* s) {
    std::cerr << "Error: " << s << std::endl;
}

%}

%union {
    std::string* str;
    Cmm::EvaluableNode* evaluable;
}

%token END

// Token definitions with C++ types
%token <str> V_STRING V_INTEGER V_COMPLEX V_REAL V_BOOLEAN
%token <str> ID

%token TYPE_REAL TYPE_INT TYPE_STR TYPE_COMPLEX TYPE_BOOL TYPE_VOID
%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV
%token OP_APLUS OP_AMINUS OP_AMULT OP_ADIV
%token OP_LS OP_RS OP_BOR OP_BAND OP_XOR
%token OP_ALS OP_ARL OP_ABOR OP_ABAND OP_AXOR
%token OP_OR OP_AND OP_NOT OP_INVERT
%token D_SEMICOLON D_LPAREN D_RPAREN D_LBRACE D_RBRACE D_COLON D_COMMA
%token CONTROL_IF CONTROL_ELSE CONTROL_WHILE CONTROL_FOR CONTROL_SWITCH
%token CONTROL_CASE CONTROL_DEFAULT CONTROL_DO CONTROL_RETURN CONTROL_BREAK CONTROL_CONTINUE
%token MISC_FUNC MISC_VAR MISC_CONST MISC_IMPORT MISC_EXPORT MISC_NATIVE

// Type declarations
%type <str> type_specifier
%type <evaluable> constant_value expr expr_value expr_term
%type <str> OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV OP_APLUS OP_AMINUS OP_AMULT OP_ADIV OP_LS OP_RS OP_BOR OP_BAND OP_XOR OP_ALS OP_ARL OP_ABOR OP_ABAND OP_AXOR OP_OR OP_AND OP_NOT OP_INVERT

%left OP_PLUS OP_MINUS
%left OP_MULT OP_DIV
%precedence OP_UNARY_MINUS

%start program

%%

program:
      expr {
        try {
          auto result = $1->eval();
          auto asStr = Cmm::ValuesHelper::castTo(result, Cmm::V_String);
          auto str_ptr = static_cast<Cmm::String*>(asStr.value);
          std::cout << *str_ptr << std::endl;
        } catch (std::exception e) {
           std::cerr << e.what() << std::endl;
        }
        YYACCEPT;
      }
    ;

expr:
      expr_term                      { $$ = $1; }
    | expr OP_PLUS expr_term         { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
    | expr OP_MINUS expr_term        { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
    ;

expr_term:
      expr_value                     { $$ = $1; }
    | expr_term OP_MULT expr_value   { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
    | expr_term OP_DIV expr_value    { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
    ;

expr_value:
      constant_value                           { $$ = $1; }
    | D_LPAREN expr D_RPAREN                   { $$ = $2; }
    | OP_MINUS expr_value %prec OP_UNARY_MINUS { $$ = new Cmm::Expressions::NegatedNode($2); }
    ;

constant_value:
      V_STRING    { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::String(*$1)); }
    | V_INTEGER   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Integer((*$1).c_str())); }
    | V_REAL      { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Real((*$1).c_str())); }
    | V_BOOLEAN   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Bool(*($1) == "true")); }
    | V_COMPLEX   { 
      $1->pop_back();
      $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Complex(Cmm::Real(0.0), Cmm::Real($1->c_str()))); 
    }
    ;

type_specifier:
      TYPE_INT      { $$ = "int"; }
    | TYPE_REAL     { $$ = "real"; }
    | TYPE_STR      { $$ = "str"; }
    | TYPE_COMPLEX  { $$ = "complex"; }
    | TYPE_BOOL     { $$ = "bool"; }
    | TYPE_VOID     { $$ = "void"; }
    ;

%%