%{
#include <iostream>
#include <string>

#include "../config.h"
#include "../forward.h"
#include "../AST.h"
#include "../primitives.h"
#include "../MathHelper.h"
#include "../Values.h"
#include "../Expressions.h"
#include "../Program.h"

#include "parser.tab.hpp"

// Declare yylex for Bison
extern int yylex();

// Error reporting function
void yyerror(const char* s) {
    std::cerr << "Error: " << s << std::endl;
}


extern Cmm::Program::ProgramNode* root;

%}

%union {
    std::string* str;
    Cmm::EvaluableNode* evaluable;
    Cmm::ExecutableNode* executable;
    Cmm::ASTNode* node;
}

%token END

// Token definitions with C++ types
%token <str> V_STRING V_INTEGER V_COMPLEX V_REAL V_BOOLEAN
%token <str> ID

%token TYPE_REAL TYPE_INT TYPE_STR TYPE_COMPLEX TYPE_BOOL TYPE_VOID
%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV
%token OP_APLUS OP_AMINUS OP_AMULT OP_ADIV
%token OP_LS OP_RS OP_BOR OP_BAND OP_XOR
%token OP_ALS OP_ARL OP_ABOR OP_ABAND OP_AXOR
%token OP_OR OP_AND OP_NOT OP_INVERT
%token D_SEMICOLON D_LPAREN D_RPAREN D_LBRACE D_RBRACE D_COLON D_COMMA D_ARROW
%token CONTROL_IF CONTROL_ELSE CONTROL_WHILE CONTROL_FOR CONTROL_SWITCH
%token CONTROL_CASE CONTROL_DEFAULT CONTROL_DO CONTROL_RETURN CONTROL_BREAK CONTROL_CONTINUE
%token MISC_FUNC MISC_FROM MISC_VAR MISC_CONST MISC_IMPORT MISC_EXPORT MISC_NATIVE

// Type declarations
%type <str> type_specifier
%type <evaluable> constant_value expr expr_value expr_term expr_casted_term func_call
%type <str> OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV OP_APLUS OP_AMINUS OP_AMULT OP_ADIV OP_LS OP_RS OP_BOR OP_BAND OP_XOR OP_ALS OP_ARL OP_ABOR OP_ABAND OP_AXOR OP_OR OP_AND OP_NOT OP_INVERT

%type <executable> program statement statements_list var_decl var_assign

%left OP_PLUS OP_MINUS
%left OP_MULT OP_DIV
%precedence OP_UNARY_MINUS

%start program

%%

//               ============== Program ==============

program:
      /* expr {
        try {
          auto result = $1->eval();
          auto asStr = Cmm::ValuesHelper::castTo(result, Cmm::V_String);
          auto str_ptr = static_cast<Cmm::String*>(asStr.value);
          std::cout << *str_ptr << std::endl;
        } catch (std::exception& e) {
          std::cerr << e.what() << std::endl;
          std::cerr << std::endl;
        }
        YYACCEPT;
      } */

      statements_list {
        $$ = new Cmm::Program::ProgramNode($1);
        root = dynamic_cast<Cmm::Program::ProgramNode*>($$);
        YYACCEPT;
      }
    ;


statements_list:
    statement                   { $$ = new Cmm::Program::StatementListNode(nullptr, $1); }
  | statements_list statement   { $$ = new Cmm::Program::StatementListNode(dynamic_cast<Cmm::Program::StatementListNode*>($1), $2); }
  ;

statement:
    expr D_SEMICOLON            { $$ = new Cmm::Program::ExpressionStatementNode($1);}
//| func_call D_SEMICOLON  // expr can be a function call
//  | func_def
  | var_decl D_SEMICOLON        { $$ = $1; }
  | var_assign D_SEMICOLON      { $$ = $1; }
  ;

/* //               ============== DEBUGGING  ==============
output_call:
  'print' D_LPAREN func_arg D_RPAREN           { std::cout << "DEBUG:" << std::endl; } */

//               ============== VARIABLES  ==============
var_decl:
    MISC_VAR   ID D_COLON type_specifier OP_ASSIGN expr { $$ = new Cmm::Program::VariableDeclarationNode(false, *$2, *$4, $6); }
  | MISC_CONST ID D_COLON type_specifier OP_ASSIGN expr { $$ = new Cmm::Program::VariableDeclarationNode(true , *$2, *$4, $6); }
  ;

var_assign:
    ID OP_ASSIGN expr                                   { $$ = new Cmm::Program::VariableAssignmentNode(*$1, $3); }

//               ============== FUNCSTIONS ==============
/* func_def:
    // func input(type: str = "str") -> str | int | real | complex | bool { .. }
    MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW type_list D_LBRACE statements_list D_RBRACE
    // func input(type: str = "str") -> str | int | real | complex | bool = native
  | MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW type_list OP_ASSIGN MISC_NATIVE D_SEMICOLON
    // export func input(type: str = "str") -> str | int | real | complex | bool { .. } 
  | MISC_EXPORT MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW type_list D_LBRACE statements_list D_RBRACE
    // export func input(type: str = "str") -> str | int | real | complex | bool = native
  | MISC_EXPORT MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW type_list OP_ASSIGN MISC_NATIVE D_SEMICOLON
  ;

func_arg:
    ID D_COLON type_specifier
  | ID D_COLON type_specifier OP_ASSIGN constant_value
  ;

func_arg_list:
    func_arg
  | func_arg_list func_arg
  ; */


func_call:
    ID D_LPAREN func_param_list D_RPAREN       { std::cout << "func: " << (*$1) << ", will be implemented soon." << std::endl; }
  | ID D_LPAREN D_RPAREN                       { std::cout << "func: " << (*$1) << ", will be implemented soon." << std::endl; }
  ;

func_param_list:
    func_param
  | func_param_list D_COMMA func_param
  ;

func_param:
    expr
  ;


//               ============== Expressions ==============

expr:
    expr_casted_term                      { $$ = $1; }
  | expr OP_PLUS expr_casted_term         { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr OP_MINUS expr_casted_term        { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  ;

expr_casted_term:
    D_LPAREN type_specifier D_RPAREN expr_term { $$ = new Cmm::Expressions::CastNode($4, *$2); }
  | expr_term                                  { $$ = $1; }
  ;

expr_term:
    expr_value                                  { $$ = $1; }
  | expr_term OP_MULT expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_DIV  expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  ;

expr_value:
    constant_value                           { $$ = $1; }
  | func_call                                { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Real("1.0")); /* TODO: implement this */ }
  | ID                                       { $$ = new Cmm::Expressions::VariableNode(*$1); }
  | D_LPAREN expr D_RPAREN                   { $$ = $2; }
  | OP_MINUS expr_value %prec OP_UNARY_MINUS { $$ = new Cmm::Expressions::NegatedNode($2); }
  | OP_PLUS  expr_value %prec OP_UNARY_MINUS { $$ = $2; }
  ;

constant_value:
    V_STRING    { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::String(*$1)); }
  | V_INTEGER   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Integer((*$1).c_str())); }
  | V_REAL      { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Real((*$1).c_str())); }
  | V_BOOLEAN   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Bool(*($1) == "true")); }
  | V_COMPLEX   { 
    $1->pop_back(); // remove the "i"
    $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Complex(Cmm::Real(0.0), Cmm::Real($1->c_str()))); 
  }
  ;



//               ============== Typing ==============

type_list:
    type_specifier                     {  }
  | type_list OP_BOR type_specifier    {  }
  ;

type_specifier:
    TYPE_INT      { $$ = new std::string("int"); }
  | TYPE_REAL     { $$ = new std::string("real"); }
  | TYPE_STR      { $$ = new std::string("str"); }
  | TYPE_COMPLEX  { $$ = new std::string("complex"); }
  | TYPE_BOOL     { $$ = new std::string("bool"); }
  | TYPE_VOID     { $$ = new std::string("void"); }
  ;

%%