%{
#include <iostream>
#include <string>

#include "../config.h"
#include "../forward.h"
#include "../AST.h"
#include "../primitives.h"
#include "../MathHelper.h"
#include "../Values.h"
#include "../Expressions.h"
#include "../Program.h"
#include "../Typing.h"
#include "../Control.h"
#include "../Variables.h"
#include "../Functional.h"

#include "parser.tab.hpp"

// Declare yylex for Bison
extern int yylex();

extern char* yytext;
extern int yylineno;
extern int yydebug;

void yyerror(const char* s) {
  std::cout << "\033[31m" << "Error at line " << yylineno << ": " << s 
              << " (unexpected token: '" << yytext << "')" 
              << "\033[0m" << std::endl;
}

extern Cmm::Program::ProgramNode* root;

%}

%union {
    std::string* str;
    Cmm::EvaluableNode* evaluable;
    Cmm::ExecutableNode* executable;
    Cmm::ASTNode* node;
    Cmm::Typing::TypeListNode* tlist;
}

%token END

// Token definitions with C++ types
%token <str> V_STRING V_INTEGER V_COMPLEX V_REAL V_BOOLEAN
%token <str> ID

%token TYPE_REAL TYPE_INT TYPE_STR TYPE_COMPLEX TYPE_BOOL TYPE_VOID
%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV OP_MOD
%token OP_APLUS OP_AMINUS OP_AMULT OP_ADIV
%token OP_LS OP_RS OP_BOR OP_BAND OP_XOR
%token OP_ALS OP_ARS OP_ABOR OP_ABAND OP_AXOR
%token OP_OR OP_AND OP_NOT OP_INVERT OP_EQUAL
%token OP_GREATER OP_LESS OP_GE OP_LE OP_NEQUAL
%token D_SEMICOLON D_LPAREN D_RPAREN D_LBRACE D_RBRACE D_COLON D_COMMA D_ARROW
%token CONTROL_IF CONTROL_ELSE CONTROL_WHILE CONTROL_FOR CONTROL_SWITCH
%token CONTROL_CASE CONTROL_DEFAULT CONTROL_DO CONTROL_RETURN CONTROL_BREAK CONTROL_CONTINUE
%token MISC_FUNC MISC_FROM MISC_VAR MISC_CONST MISC_IMPORT MISC_EXPORT MISC_NATIVE

// Type declarations
%type <str> OP_EQUAL OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV OP_MOD OP_APLUS OP_AMINUS OP_AMULT OP_ADIV OP_LS OP_RS OP_BOR OP_BAND OP_XOR OP_ALS OP_ARS OP_ABOR OP_ABAND OP_AXOR OP_OR OP_AND OP_NOT OP_INVERT
%type <str> OP_GREATER OP_LESS OP_GE OP_LE OP_NEQUAL

%type <str> type_specifier
%type <evaluable> constant_value expr expr_value expr_term expr_casted_term

%type <executable> program statement statements_list var_decl_stmt var_assign_stmt

%type <executable> func_def return_stmt scope_stmt
%type <node>       func_arg_list func_arg 
%type <tlist>      types_list

%type <evaluable>  func_param func_call 
%type <node>       func_param_list

%type <executable> if_stmt for_stmt break_stmt continue_stmt while_stmt

%left OP_PLUS OP_MINUS
%left OP_MULT OP_DIV
%precedence OP_UNARY_MINUS

%nonassoc CONTROL_IF
%nonassoc LOWER_THAN_ELSE
%nonassoc CONTROL_ELSE

%start program

%%


 /* expr {
        try {
          auto result = $1->eval();
          auto asStr = Cmm::ValuesHelper::castTo(result, Cmm::V_String);
          auto str_ptr = static_cast<Cmm::String*>(asStr.value);
          std::cout << *str_ptr << std::endl;
        } catch (std::exception& e) {
          std::cerr << e.what() << std::endl;
          std::cerr << std::endl;
        }
        YYACCEPT;
      } */

//               ============== Program ==============

program:
      statements_list END {
        $$ = new Cmm::Program::ProgramNode($1);
        root = dynamic_cast<Cmm::Program::ProgramNode*>($$);
        YYACCEPT;
      }
    ;


statements_list:
    statement                   { $$ = new Cmm::Program::StatementListNode(nullptr, $1); }
  | statements_list statement   { $$ = new Cmm::Program::StatementListNode(dynamic_cast<Cmm::Program::StatementListNode*>($1), $2); }
  ;

statement:
    expr D_SEMICOLON                 { $$ = new Cmm::Program::ExpressionStatementNode($1);}
  | var_decl_stmt D_SEMICOLON        { $$ = $1; }
  | var_assign_stmt D_SEMICOLON      { $$ = $1; }
  | return_stmt D_SEMICOLON          { $$ = $1; }
  | func_def                         { $$ = $1; }
  | scope_stmt                       { $$ = $1; }
  | if_stmt                          { $$ = $1; }
  | for_stmt                         { $$ = $1; }
  | while_stmt                       { $$ = $1; }
  | continue_stmt D_SEMICOLON        { $$ = $1; }
  | break_stmt D_SEMICOLON           { $$ = $1; }
  | D_SEMICOLON                      { $$ = nullptr; } // just a semicolon
  ;

//               ==============  CONTROL   ==============
if_stmt:
    CONTROL_IF D_LPAREN expr D_RPAREN statement %prec LOWER_THAN_ELSE
    { $$ = new Cmm::Control::IFNode($3, $5, nullptr); }
  | CONTROL_IF D_LPAREN expr D_RPAREN statement CONTROL_ELSE statement
    { $$ = new Cmm::Control::IFNode($3, $5, $7); } 
  ;

for_stmt:
    CONTROL_FOR D_LPAREN var_decl_stmt D_SEMICOLON expr D_SEMICOLON var_assign_stmt D_RPAREN statement { $$ = new Cmm::Control::ForNode($5, $3, $7, $9); }
  | CONTROL_FOR D_LPAREN D_SEMICOLON expr D_SEMICOLON D_RPAREN statement                               { $$ = new Cmm::Control::ForNode($4, nullptr, nullptr, $7); }
  | CONTROL_FOR D_LPAREN D_SEMICOLON D_SEMICOLON D_RPAREN statement                                    { $$ = new Cmm::Control::ForNode(nullptr, nullptr, nullptr, $6); }
  | CONTROL_FOR D_LPAREN D_SEMICOLON expr D_SEMICOLON var_assign_stmt D_RPAREN statement               { $$ = new Cmm::Control::ForNode($4, nullptr, $6, $8); }
  ; 

while_stmt: 
    CONTROL_WHILE D_LPAREN expr D_RPAREN statement                               { $$ = new Cmm::Control::ForNode($3, nullptr, nullptr, $5); }
  | CONTROL_DO statement CONTROL_WHILE D_LPAREN expr D_RPAREN D_SEMICOLON        { $$ = new Cmm::Control::ForNode($5, nullptr, nullptr, $2, true); }
  ;

break_stmt:
    CONTROL_BREAK                                         { $$ = new Cmm::Control::BreakStatementNode(); } 
  ;

continue_stmt:
    CONTROL_CONTINUE                                      { $$ = new Cmm::Control::ContinueStatementNode(); } 
  ;


return_stmt:
    CONTROL_RETURN expr                                   { $$ = new Cmm::Control::ReturnStatementNode($2); } 
  | CONTROL_RETURN                                        { $$ = new Cmm::Control::ReturnStatementNode(nullptr); } 
  ;

//               ============== VARIABLES  ==============
var_decl_stmt:
    MISC_VAR   ID D_COLON type_specifier OP_ASSIGN expr { $$ = new Cmm::Variables::VariableDeclarationNode(false, *$2, *$4, $6); }
  | MISC_CONST ID D_COLON type_specifier OP_ASSIGN expr { $$ = new Cmm::Variables::VariableDeclarationNode(true , *$2, *$4, $6); }
  ;

var_assign_stmt:
    ID OP_ASSIGN expr                                   { $$ = new Cmm::Variables::VariableAssignmentNode(*$1, $3); }
  ;

//               ============== FUNCSTIONS ==============
scope_stmt:
    D_LBRACE statements_list D_RBRACE {
      $$ = new Cmm::Program::ScopeNode($2);
    }
    | D_LBRACE D_RBRACE {
      $$ = new Cmm::Program::ScopeNode(nullptr); // empty scope
    }
  ;
func_def:
    // func input(type: str = "str") -> str | int | real | complex | bool { .. }
    MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW types_list D_LBRACE statements_list D_RBRACE { 
      $$ = new Cmm::Functional::FunctionDeclarationNode(new Cmm::Functional::FunctionNode(
        dynamic_cast<Cmm::Functional::FunctionArgumentListNode*>($4),
        dynamic_cast<Cmm::Program::StatementListNode*>($9),
        *$2,
        $7
      ));
  }
    // func input(type: str = "str") -> str | int | real | complex | bool = native
  | MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW types_list OP_ASSIGN MISC_NATIVE D_SEMICOLON { $$ = nullptr; } // later
    // export func input(type: str = "str") -> str | int | real | complex | bool { .. } 
  | MISC_EXPORT MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW types_list D_LBRACE statements_list D_RBRACE { $$ = nullptr; } // will deal with you later ..
    // export func input(type: str = "str") -> str | int | real | complex | bool = native
  | MISC_EXPORT MISC_FUNC ID D_LPAREN func_arg_list D_RPAREN D_ARROW types_list OP_ASSIGN MISC_NATIVE D_SEMICOLON { $$ = nullptr; }
  ;

func_arg:
    ID D_COLON type_specifier                            { $$ = new Cmm::Functional::FunctionArgumentNode(*$1, *$3); }
  | ID D_COLON type_specifier OP_ASSIGN constant_value   { $$ = new Cmm::Functional::FunctionArgumentNode(*$1, *$3, $5); }
  ;

func_arg_list:
    func_arg                                   { $$ = new Cmm::Functional::FunctionArgumentListNode(nullptr, dynamic_cast<Cmm::Functional::FunctionArgumentNode*>($1)); }
  | func_arg_list D_COMMA func_arg             { $$ = new Cmm::Functional::FunctionArgumentListNode(dynamic_cast<Cmm::Functional::FunctionArgumentListNode*>($1), dynamic_cast<Cmm::Functional::FunctionArgumentNode*>($3)); }
  |                                            { $$ = new Cmm::Functional::FunctionArgumentListNode(nullptr, nullptr); }
  ;


func_call:
    ID D_LPAREN func_param_list D_RPAREN       { $$ = new Cmm::Functional::FunctionCallNode(*$1, dynamic_cast<Cmm::Functional::FunctionParamListNode*>($3)); }
  | ID D_LPAREN D_RPAREN                       { $$ = new Cmm::Functional::FunctionCallNode(*$1, nullptr); }
  ;

func_param_list:
    func_param                                 { $$ = new Cmm::Functional::FunctionParamListNode(nullptr, $1); }
  | func_param_list D_COMMA func_param         { $$ = new Cmm::Functional::FunctionParamListNode(dynamic_cast<Cmm::Functional::FunctionParamListNode*>($1), $3); }
  ;

func_param:
    expr                                       { $$ = $1; }
  ;


//               ============== Expressions ==============

expr:
    expr_casted_term                      { $$ = $1; }
  | expr OP_PLUS expr_casted_term         { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr OP_MINUS expr_casted_term        { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  ;

expr_casted_term:
    D_LPAREN type_specifier D_RPAREN expr_term { $$ = new Cmm::Expressions::CastNode($4, *$2); }
  | expr_term                                  { $$ = $1; }
  ;

expr_term:
    expr_value                                  { $$ = $1; }
  | expr_term OP_MULT expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_DIV  expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_LS expr_value                  { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_RS expr_value                  { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_BOR expr_value                 { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_BAND expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_XOR expr_value                 { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_OR expr_value                  { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_AND expr_value                 { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_EQUAL expr_value               { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_GREATER expr_value             { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_LESS expr_value                { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_LE expr_value                  { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_GE expr_value                  { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_NEQUAL expr_value              { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  | expr_term OP_MOD expr_value                 { $$ = new Cmm::Expressions::TermNode($1, $3, *$2); }
  ;

expr_value:
    constant_value                           { $$ = $1; }
  | func_call                                { $$ = $1; }
  | ID                                       { $$ = new Cmm::Expressions::VariableNode(*$1); }
  | D_LPAREN expr D_RPAREN                   { $$ = $2; }
  | OP_MINUS  expr_value %prec OP_UNARY_MINUS  { $$ = new Cmm::Expressions::NegatedNode($2); }
  | OP_PLUS   expr_value %prec OP_UNARY_MINUS  { $$ = $2; }
  | OP_NOT    expr_value %prec OP_UNARY_MINUS  { $$ = new Cmm::Expressions::NotNode($2); }
  | OP_INVERT expr_value %prec OP_UNARY_MINUS  { $$ = new Cmm::Expressions::InvertNode($2); }
  ;

constant_value:
    V_STRING    { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::String(*$1)); }
  | V_INTEGER   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Integer((*$1).c_str())); }
  | V_REAL      { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Real((*$1).c_str())); }
  | V_BOOLEAN   { $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Bool(*($1) == "true")); }
  | V_COMPLEX   { 
    $1->pop_back(); // remove the "i"
    $$ = new Cmm::Expressions::ConstantValueNode(Cmm::Complex(Cmm::Real(0.0), Cmm::Real($1->c_str()))); 
  }
  ;

//               ============== Typing ==============

types_list:
    type_specifier                      { $$ = new Cmm::Typing::TypeListNode(nullptr, *$1); }
  | types_list OP_BOR type_specifier    { $$ = new Cmm::Typing::TypeListNode($1, *$3); }
  ;

type_specifier:
    TYPE_INT      { $$ = new std::string("int"); }
  | TYPE_REAL     { $$ = new std::string("real"); }
  | TYPE_STR      { $$ = new std::string("str"); }
  | TYPE_COMPLEX  { $$ = new std::string("complex"); }
  | TYPE_BOOL     { $$ = new std::string("bool"); }
  | TYPE_VOID     { $$ = new std::string("void"); }
  ;

%%