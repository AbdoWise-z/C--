%{
#include <iostream>
#include <string>
#include "parser.tab.hpp"
#include "../Expressions.h"
// Declare yylex for Bison
extern int yylex();

// Error reporting function
void yyerror(const char* s) {
    std::cerr << "Error: " << s << std::endl;
}

%}

%union {
    std::string* str;
}

%token END

// Token definitions with C++ types
%token <str> V_STRING V_INTEGER V_COMPLEX V_REAL V_BOOLEAN
%token <str> ID

%token TYPE_REAL TYPE_INT TYPE_STR TYPE_COMPLEX TYPE_BOOL TYPE_VOID
%token OP_ASSIGN OP_PLUS OP_MINUS OP_MULT OP_DIV
%token OP_APLUS OP_AMINUS OP_AMULT OP_ADIV
%token OP_LS OP_RS OP_BOR OP_BAND OP_XOR
%token OP_ALS OP_ARL OP_ABOR OP_ABAND OP_AXOR
%token OP_OR OP_AND OP_NOT OP_INVERT
%token D_SEMICOLON D_LPAREN D_RPAREN D_LBRACE D_RBRACE D_COLON D_COMMA
%token CONTROL_IF CONTROL_ELSE CONTROL_WHILE CONTROL_FOR CONTROL_SWITCH
%token CONTROL_CASE CONTROL_DEFAULT CONTROL_DO CONTROL_RETURN CONTROL_BREAK CONTROL_CONTINUE
%token MISC_FUNC MISC_VAR MISC_CONST MISC_IMPORT MISC_EXPORT MISC_NATIVE

// Type declarations
%type <str> type_specifier

%left OP_PLUS OP_MINUS
%left OP_MULT OP_DIV
%precedence OP_UNARY_MINUS

%start program

%%

program:
      expr {
        std::cout << "Program ok :)" << std::endl;
        YYACCEPT;
      }
    ;

expr:
      expr_term
    | expr OP_PLUS expr_term 
    | expr OP_MINUS expr_term  
    ;

expr_term:
      expr_value
    | expr_term OP_MULT expr_value 
    | expr_term OP_DIV expr_value  
    ;

expr_value:
      constant_value
    | D_LPAREN expr D_RPAREN
    | OP_MINUS expr_value %prec OP_UNARY_MINUS
    ;

constant_value:
      V_STRING  
    | V_INTEGER  
    | V_REAL  
    | V_BOOLEAN 
    ;

type_specifier:
      TYPE_INT      { $$ = "int"; }
    | TYPE_REAL     { $$ = "real"; }
    | TYPE_STR      { $$ = "str"; }
    | TYPE_COMPLEX  { $$ = "complex"; }
    | TYPE_BOOL     { $$ = "bool"; }
    | TYPE_VOID     { $$ = "void"; }
    ;

%%